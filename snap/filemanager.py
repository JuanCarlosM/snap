# High level file manager / helper
#
# (C) Copyright 2011 Mo Morsi (mo@morsi.org)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 3,
# as published by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import os
import shutil
import tempfile
import subprocess

import snap.exceptions

class FileManager:
    """Snap file manager, performs many high level file operations"""

    def rm(target):
        '''remove the specified file - static method

        @param target - the path to the file to remove
        @raises FileSystemError - if the file could not be removed'''
        try:
            os.remove(target)
        except:
            raise snap.exceptions.FilesystemError("Could not remove file " + target)
    rm = staticmethod(rm)

    def mv(source, dest):
        '''move specified source file to dest

        @param source - path to the file to move
        @param dest - path to the location to move the file to'''
        try:
            shutil.move(source, dest)
        except:
            raise snap.exceptions.FilesystemError("Could not move the file " + source + " to " + dest)
    mv = staticmethod(mv)

    def make_dir(target):
        '''create the specified directory - static method

        @param target - the path to the directory to create
        @raises FileSystemError - if the directory could not be created
        '''

        try:
            if not os.path.isdir(target):
                os.mkdir(target)
        except:
            raise snap.exceptions.FilesystemError("Could not make directory " + target)
    make_dir = staticmethod(make_dir)

    def rm_dir(target):
        '''remove the specified directory - static method

        @param target - the path to the directory to remove
        @raises FileSystemError - if the directory could not be removed
        '''

        try:
            if os.path.isdir(target):
                shutil.rmtree(target)
        except:
            raise snap.exceptions.FilesystemError("Could not remove directory " + target)
    rm_dir = staticmethod(rm_dir)


    def exists(path):
        '''return true if the file specified by the given path exists, else false

        @param path - path to th file to check
        @return - true if the file exists, else false'''
        
        return os.path.exists(path)
    exists = staticmethod(exists)

    def read_file(path):
        '''return and return the entire contents of the specified file

        @param path - path to th file to check
        @return - contents of the file exists'''

        try:
            f = open(path, 'r')
            c = f.read()
            f.close()
            return c
        except:
            raise snap.exceptions.FilesystemError("Could not read file " + path)
    read_file = staticmethod(read_file)

    def capture_output(command, env=os.environ):
        '''runs the specified command, capturing and returning output

        @param command - array containing executable to run w/ parameters
        @param env - optional environment to set for command
        @return - stdout generated by the command, if any'''
        # TODO we may want to play this in its own module at some point

        stdoutf = tempfile.TemporaryFile()
        #nullf = open(OSUtils.null_file(), 'w')
        popen   = subprocess.Popen(command, env=env, stdout=stdoutf)#, stderr=nullf)
        popen.wait()

        stdoutf.seek(0)
        stdout = stdoutf.read()
        stdoutf.close()

        return stdout
    capture_output = staticmethod(capture_output)

    def get_all_files(include=[], exclude=[]):
        '''return a list of paths corresponding to files in one or more directories - static method

        @param include - list of files/directories to include
        @param exclude - list of files/directories to exclude'''
        if len(include) == 0:
            include.append(snap.osregistry.OS.get_root())
        
        files = []
        # iterate over each include in the list
        for ifile in include:
            try:
                # if its a file, simple add if we haven't already
                if os.path.isfile(ifile):
                    if not ifile in files and \
                       not ifile in exclude:
                        files.append(ifile)

                # if its a directory add all files in it and its subdirs
                elif os.path.isdir(ifile):
                    idir = ifile

                    children = os.listdir(idir) + \
                               FileManager.get_all_subdirectories(idir)

                    for child in children:
                        fullpath = os.path.join(idir, child)
                        if not fullpath in exclude:
                            cfiles = [fullpath]
                            if os.path.isdir(fullpath):
                                cfiles = FileManager.get_all_files(cfiles, exclude)
                            for cpath in cfiles:
                                if not cpath in files and \
                                   not cpath in exclude:
                                    files.append(cpath)

            except:
                pass # silently ignore errors
        return files
    get_all_files = staticmethod(get_all_files)

    def get_all_subdirectories(directory=None, recursive=False):
        '''return a list of full paths to subdirectories under the specified directory
        
        @param directory - the directory to get subdirectories of
        '''
        if directory == None:
            directory = snap.osregistry.OS.get_root()
        
        subdirs = []
        # iterate over all files in directory
        for item in os.listdir(directory):
            fullpath = os.path.join(directory, item)
            # get subdirectories
            if os.path.isdir(fullpath) and not fullpath in subdirs:
                subdirs.append(fullpath)
                # recusrively iterate over subdirectories
                if recursive:
                    subsubdirs = FileManager.get_all_subdirectories(fullpath)
                    for subsubdir in subsubdirs:
                        if not subsubdir in subdirs:
                            subdirs.append(subsubdir)
        return subdirs
    get_all_subdirectories = staticmethod(get_all_subdirectories)
