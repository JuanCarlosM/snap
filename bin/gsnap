#!/usr/bin/python
#
# (C) Copyright 2011 Mo Morsi (mo@morsi.org)
#
# gsnap - snap gtk gui
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 3,
# as published by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import sys
#import threading

#GLADE_FILE="/usr/share/snap/snap-redux.glade"
GLADE_FILE="/home/mmorsi/workspace/snap/resources/snap-redux.glade"

import snap
import snap.callback
#from snap.exceptions import *
#from snap.configmanager import ConfigManager

try:
    import pygtk
    pygtk.require("2.0")
except:
    pass
try:
    import gtk
    import gtk.glade
except:
     sys.exit(1)

# The main window
class ModeSelectionWindow:

     @classmethod
     def set_instance(cls, instance):
        '''store a singleton instance of this window for future reference'''
        cls.instance = instance

     @classmethod
     def get_instance(cls):
         '''get singleton instance of this class'''
         return cls.instance

     def __init__(self):
        self.wTree = gtk.glade.XML(GLADE_FILE, "mode_selection") 
                                         
        # map the gui signals
        dic = { "show_backup_window"   : self.show_backup_window,
                "show_restore_window"  : self.show_restore_window,
                "show_help_dialog"     : self.show_help_dialog,
                "close_window"         : self.close_window}
        self.wTree.signal_autoconnect(dic)

        self.dlg = self.wTree.get_widget("mode_selection")
        
        ModeSelectionWindow.set_instance(self)
     
     def run(self):
         self.dlg.show()

     def show_backup_window(self, widget):
         window = BackupOperationWindow()
         self.dlg.hide()
         window.run()

     def show_restore_window(self, widget):
         window = RestoreOperationWindow()
         self.dlg.hide()
         window.run()

     def show_help_dialog(self, widget):
         dlg = HelpDialog()
         dlg.run()

     def close_window(self, widget):
         gtk.main_quit

# The backup operation window
class BackupOperationWindow:
    def __init__(self):
       self.wTree = gtk.glade.XML(GLADE_FILE, "backup_options") 
                                        
       # map the gui signals
       dic = { "start_backup"           : self.start_backup,
               "close_backup_window"    : self.close_backup_window }
       self.wTree.signal_autoconnect(dic)

       self.dlg = self.wTree.get_widget("backup_options")

       self._setup_log_levels()

    def run(self):
       self.dlg.show()

    def _setup_log_levels(self):
        combobox = self.wTree.get_widget("backup_log_level")
        combobox.append_text("quiet")
        combobox.append_text("normal")
        combobox.append_text("verbose")
        combobox.append_text("debug")

    def _get_log_level(self):
        combobox = self.wTree.get_widget("backup_log_level")
        model    = combobox.get_model()
        active   = combobox.get_active()
        if active < 0:
            return "normal"
        return model[active][0]

    def _get_config(self):
        snap.config.options.log_level = self._get_log_level()
        snap.config.options.snapfile  = self.wTree.get_widget("backup_snapfile").get_text()

        if self.wTree.get_widget("backup_repos_toggle").get_active():
            snap.config.options.target_backends['repos'] = True
        if self.wTree.get_widget("backup_packages_toggle").get_active():
            snap.config.options.target_backends['packages'] = True
        if self.wTree.get_widget("backup_files_toggle").get_active():
            snap.config.options.target_backends['files'] = True

    def start_backup(self, widget):
        conf = snap.config.Config()
        conf.read_config()
        self._get_config()
        conf.verify_integrity()
        snapbase = snap.SnapBase()
        snapbase.backup()

    def close_backup_window(self, widget):
        self.dlg.hide()
        ModeSelectionWindow.get_instance().run()


# The backup operation window
class RestoreOperationWindow:
    def __init__(self):
       self.wTree = gtk.glade.XML(GLADE_FILE, "restore_options") 
                                        
       # map the gui signals
       dic = { "start_restore"          : self.start_restore,
               "close_restore_window"   : self.close_restore_window }
       self.wTree.signal_autoconnect(dic)

       self.dlg = self.wTree.get_widget("restore_options")

       self._setup_log_levels()

    def run(self):
       self.dlg.show()

    def _setup_log_levels(self):
        combobox = self.wTree.get_widget("backup_log_level")
        combobox.append_text("quiet")
        combobox.append_text("normal")
        combobox.append_text("verbose")
        combobox.append_text("debug")

    def _get_log_level(self):
        combobox = self.wTree.get_widget("restore_log_level")
        model    = combobox.get_model()
        active   = combobox.get_active()
        if active < 0:
            return "normal"
        return model[active][0]

    def _get_config(self):
        snap.config.options.log_level = self._get_log_level()
        snap.config.options.snapfile  = self.wTree.get_widget("backup_snapfile").get_text()

    def start_restore(self, widget):
        conf = snap.config.Config()
        conf.read_config()
        self._get_config()
        conf.verify_integrity()
        snapbase = snap.SnapBase()
        snapbase.restore()

    def close_restore_window(self, widget):
        self.dlg.hide()
        ModeSelectionWindow.get_instance().run()

# The help dialog
class HelpDialog:
    def __init__(self):
       self.wTree = gtk.glade.XML(GLADE_FILE, "help_window") 
                                        
       # map the gui signals
       dic = { "close_help_dialog"      : self.close_help_dialog}
       self.wTree.signal_autoconnect(dic)

       self.dlg = self.wTree.get_widget("help_window")

    def run(self):
       self.dlg.show()

    def close_help_dialog(self, widget):
        self.dlg.hide()
        ModeSelectionWindow.get_instance().run()

# The output dialog
class OutputDialog:
    @classmethod
    def set_instance(cls, instance):
       '''store a singleton instance of this dialog for future reference'''
       cls.instance = instance

    @classmethod
    def get_instance(cls):
        '''get singleton instance of this class'''
        return cls.instance

    def __init__(self):
       self.wTree = gtk.glade.XML(GLADE_FILE, "output_window") 

       # map the gui signals
       dic = { "close_output_dialog"      : self.close_dialog}
       self.wTree.signal_autoconnect(dic)

       # set the output buffer
       snap.callback.snapcallback.set_output_buffer(self.wTree.get_widget("output_text").get_buffer())

       self.dlg = self.wTree.get_widget("output_window")

       OutputDialog.set_instance(self)

    def run(self):
       self.dlg.show()

    def close_dialog(self, widget):
        self.dlg.hide()


# Redirect callback text to main window
class GSnapCallback(snap.callback.Callback):
    def set_output_buffer(self, output_buffer):
        self.outputbuffer = output_buffer

    def _append_to_buffer(self, newtext):
        # always show the output dialog on new text
        OutputDialog.get_instance().run()

        gtk.gdk.threads_enter()
        nl = ''
        if self.outputbuffer.get_char_count() != 0:
            nl = '\n'
        self.outputbuffer.insert(self.outputbuffer.get_end_iter(), nl + newtext)
        gtk.gdk.threads_leave()

    def message(self, msg):
        self._append_to_buffer(msg)

    def warn(self, warning):
        self._append_to_buffer("WARNING: " + warning)

    def error(self, error):
        self._append_to_buffer("ERROR: " + error)


if __name__ == "__main__":
    # initialize callback
    snap.callback.snapcallback = GSnapCallback()

    # initialize windows
    OutputDialog()
    ModeSelectionWindow().run()
    #threading.Thread(target=self.run).start()

    # start gtk loop
    gtk.gdk.threads_init()
    gtk.main()
