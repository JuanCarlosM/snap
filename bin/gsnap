#!/usr/bin/python
#
# (C) Copyright 2011 Mo Morsi (mo@morsi.org)
#
# gsnap - snap gtk gui
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 3,
# as published by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import sys
import time
#import threading

#GLADE_FILE="/usr/share/snap/snap-redux.glade"
GLADE_FILE="/home/mmorsi/workspace/snap/resources/snap-redux.glade"

import snap
import snap.callback
#from snap.exceptions import *
#from snap.configmanager import ConfigManager

from gi.repository import Gtk

# The main window
class ModeSelectionWindow:

    @classmethod
    def set_instance(cls, instance):
       '''store a singleton instance of this window for future reference'''
       cls.instance = instance

    @classmethod
    def get_instance(cls):
        '''get singleton instance of this class'''
        return cls.instance

    def __init__(self):
       ModeSelectionWindow.set_instance(self)

       self.builder = Gtk.Builder() 
       self.builder.add_objects_from_file(GLADE_FILE, ["mode_selection"])

       self.window = self.builder.get_object("mode_selection") 
                                        
       # map the gui signals
       self.builder.connect_signals(self)
       self.window.connect("destroy", Gtk.main_quit)
    
    def show(self):
        self.window.show()

    def show_backup_window(self, widget):
        backup_window = BackupOperationWindow()
        self.window.hide()
        backup_window.show()

    def show_restore_window(self, widget):
        restore_window = RestoreOperationWindow()
        self.window.hide()
        restore_window.show()

    def show_help_dialog(self, widget):
        help_dialog = HelpDialog()
        help_dialog.show()

    def close_window(self, widget):
        Gtk.main_quit()

# The backup operation window
class BackupOperationWindow:
    def __init__(self):
       self.builder = Gtk.Builder() 
       self.builder.add_objects_from_file(GLADE_FILE, 
          [ "backup_options",      "backup_snapfile",        "backup_log_level", 
            "backup_repos_toggle", "backup_packages_toggle", "backup_files_toggle",
            "backup_encryption_toggle", "backup_encryption_key"])
       self.window = self.builder.get_object("backup_options") 
                                        
       # map the gui signals
       self.builder.connect_signals(self)
       self.window.connect("destroy", self.close_backup_window)

       self._setup_log_levels()

       # XXX bit of a hack, since GtkFileChooserButton will not currently allow
       #  use to operate in 'save' mode, eg where the user can create a new file,
       #  we create a temporary one and set it here for the time being
       # https://bugzilla.gnome.org/show_bug.cgi?id=662837
       self.snapbase = snap.SnapBase()
       snapfile_id = time.strftime('%m.%d.%Y-%H.%M.%S')
       snapfile = snap.options.DEFAULT_SNAPFILE + "-" + snapfile_id + ".tgz"
       file(snapfile, "w")
       self.builder.get_object("backup_snapfile").set_filename(snapfile)

    def show(self):
       self.window.show()

    def _setup_log_levels(self):
        combobox = self.builder.get_object("backup_log_level")
        combobox.append_text("quiet")
        combobox.append_text("normal")
        combobox.append_text("verbose")
        combobox.append_text("debug")

    def _get_config(self):
        snap.config.options.log_level = self.builder.get_object("backup_log_level").get_active_text()
        snap.config.options.snapfile  = self.builder.get_object("backup_snapfile").get_text()

        if self.builder.get_object("backup_repos_toggle").get_active():
            snap.config.options.target_backends['repos'] = True
        if self.builder.get_object("backup_packages_toggle").get_active():
            snap.config.options.target_backends['packages'] = True
        if self.builder.get_object("backup_files_toggle").get_active():
            snap.config.options.target_backends['files'] = True

    def start_backup(self, widget):
        OutputDialog.get_instance().show()
        conf = snap.config.Config()
        conf.read_config()
        self._get_config()
        conf.verify_integrity()
        self.snapbase.backup()
        OutputDialog.get_instance().quit_when_closed = True

    def close_backup_window(self, widget):
        self.window.hide()
        ModeSelectionWindow.get_instance().show()

    def backup_encryption_toggled(self, widget):
        key = self.builder.get_object("backup_encryption_key")
        key.set_visible(widget.get_active())

    def backup_encryption_key_focus_in(self, widget, param):
        if widget.get_text() == "Password":
            widget.set_text("")
            widget.set_visibility(False)

    def backup_encryption_key_focus_out(self, widget, param):
        if widget.get_text() == "":
            widget.set_text("Password")
            widget.set_visibility(True)


# The backup operation window
class RestoreOperationWindow:
    def __init__(self):
       self.builder = Gtk.Builder() 
       self.builder.add_objects_from_file(GLADE_FILE,
         ["restore_options", "restore_snapfile", "restore_log_level",
          "restore_encryption_toggle", "restore_encryption_key"])
       self.window = self.builder.get_object("restore_options") 
                                        
       # map the gui signals
       self.builder.connect_signals(self)
       self.window.connect("destroy", self.close_restore_window)

       self._setup_log_levels()

    def show(self):
       self.window.show()

    def _setup_log_levels(self):
        combobox = self.builder.get_object("restore_log_level")
        combobox.append_text("quiet")
        combobox.append_text("normal")
        combobox.append_text("verbose")
        combobox.append_text("debug")

    def _get_config(self):
        snap.config.options.log_level = self.builder.get_object("restore_log_level").get_active_text()
        snap.config.options.snapfile  = self.builder.get_object("backup_snapfile").get_text()

    def start_restore(self, widget):
        OutputDialog.get_instance().show()
        conf = snap.config.Config()
        conf.read_config()
        self._get_config()
        conf.verify_integrity()
        snapbase = snap.SnapBase()
        snapbase.restore()
        OutputDialog.get_instance().quit_when_closed = True

    def close_restore_window(self, widget):
        self.window.hide()
        ModeSelectionWindow.get_instance().show()

    def restore_encryption_toggled(self, widget):
        key = self.builder.get_object("restore_encryption_key")
        key.set_visible(widget.get_active())

    def restore_encryption_key_focus_in(self, widget):
        if widget.get_text() == "Password":
            widget.set_text("")
            widget.set_visibility(False)

    def restore_encryption_key_focus_out(self, widget):
        if widget.get_text() == "":
            widget.set_text("Password")
            widget.set_visibility(True)

# The help dialog
class HelpDialog:
    def __init__(self):
       self.builder = Gtk.Builder() 
       self.builder.add_objects_from_file(GLADE_FILE, ["help_window"])
       self.window = self.builder.get_object("help_window") 
                                        
       # map the gui signals
       self.builder.connect_signals(self)

    def show(self):
       self.window.show()

    def close_help_dialog(self, widget):
        self.window.hide()
        ModeSelectionWindow.get_instance().show()

# The output dialog
class OutputDialog:
    @classmethod
    def set_instance(cls, instance):
       '''store a singleton instance of this dialog for future reference'''
       cls.instance = instance

    @classmethod
    def get_instance(cls):
        '''get singleton instance of this class'''
        return cls.instance

    def __init__(self):
       OutputDialog.set_instance(self)

       self.builder = Gtk.Builder() 
       self.builder.add_objects_from_file(GLADE_FILE, ["output_window", "output_text"])
       self.window = self.builder.get_object("output_window") 

       # map the gui signals
       #dic = { "close_output_dialog"      : self.close_dialog}
       self.builder.connect_signals(self)

       # set the output buffer
       snap.callback.snapcallback.set_output_buffer(self.builder.get_object("output_text").get_buffer())

       self.quit_when_closed = False

    def show(self):
       self.window.show()

    def close_output_dialog(self, widget):
        if self.quit_when_closed:
            Gtk.main_quit()
        else:
            self.window.hide()


# Redirect callback text to main window
class GSnapCallback(snap.callback.Callback):
    def set_output_buffer(self, output_buffer):
        self.outputbuffer = output_buffer

    def _append_to_buffer(self, newtext):
        # always show the output dialog on new text
        OutputDialog.get_instance().run()

        Gtk.gdk.threads_enter()
        nl = ''
        if self.outputbuffer.get_char_count() != 0:
            nl = '\n'
        self.outputbuffer.insert(self.outputbuffer.get_end_iter(), nl + newtext)
        Gtk.gdk.threads_leave()

    def message(self, msg):
        self._append_to_buffer(msg)

    def warn(self, warning):
        self._append_to_buffer("WARNING: " + warning)

    def error(self, error):
        self._append_to_buffer("ERROR: " + error)


if __name__ == "__main__":
    # initialize callback
    snap.callback.snapcallback = GSnapCallback()

    # initialize windows
    OutputDialog()
    ModeSelectionWindow().show()

    # start gtk loop
    Gtk.main()
